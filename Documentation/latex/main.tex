\documentclass{article}  % Document class (can be article, report, book, etc.)

% Preamble: add packages here (optional)
\usepackage[utf8]{inputenc}  % Ensures proper encoding
\usepackage{amsmath}  % Math symbols package (optional)
\usepackage{graphicx} % Allows inclusion of images (optional)

\parindent 0mm

\title{Digitales Wahlsystem}
\author{
    Muhamedbaqir Al-Rumeil \and 
    Tizian Grossmann \and 
    Leon Meier
    }

\date{\today}  % Can be \today for today's date for a specific date

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}
\section{Anforderungen an verteilte Systeme}

Heutzutage werden viele Softwarelösungen nach einer verteilten Architektur gerichtet, um Use-Case spezifische Anforderungen besser (oder überhaupt) erfüllen zu können. \\
Die Anforderungen an eine Lösung und die Herausforderungen einer möglichen verteilten Architektur sind immer spezifisch, mögliche Anforderungen wären: Ausfallsicherheit, geringe Latenzen, Datenredundanz, etc.

Es ist wichtig zu erkennen, dass die Architektur nicht willkürlich alle möglichen Ziele erfüllen kann, sondern sich nach dem zugrunde liegenden Problem richten sollte. In einem ERP-System hat die Latenz beispielsweise nicht den selben Stellenwert wie in einem autonomen Fahrsystem. \\
Es bedarf also immer einer gründlichen Analyse der Anforderungen, um die Architektur sinnvoll umsetzen zu können. \\


Dieses Paper befasst sich mit der Planung und Implementation eines Wahlsystems, welches die deutsche Bundestagswahl, mitsamt Erst- und Zweitstimme abbilden soll. Unser Ziel ist es, ein verteiltes System zu definieren, welches eine hohe Verfügbarkeit und gute horizontale Skalierbarkeit aufweist.
  
\newpage

\section{Ablauf einer Bundestagswahl}
Der analoge Ablauf einer Bundestagswahl ist gesetzlich definiert und erlaubt unserem digitalem Wahlsystem keinerlei Abweichung. Folgendes Diagramm beschreibt (vereinfacht) den Prozess, den wir digitalisieren wollen. \\

festlegung der wahlkreise -> festlegung der kandidaten für einen wahlkreis -> festlegung der parteien für den bundestag -> beginn der wahl -> Wähler autentifiziert sich -> Wähler gibt stimme ab -> ablauf der wahlperiode -> auswertung der stimmen -> ausgabe der ergebnisse

/* Diagramm */ 

Aus dem Ablauf der Wahl kristallisieren die wichtigsten Anforderungen: \\
\begin{itemize}
    \item Schnelle Schreibgeschwindigkeiten: Die größte Last auf die Datenbank(en) wird das Einfügen der Stimmen sein. Die Leseoperationen (Kandidaten, Parteien, Wahlkreise) sind während der Wahl statisch und das Auswerten (ebenfalls eine Leseoperation) geschieht nur einmalig zum Ende einer Wahl. 

    \item Schutz vor Datenverlust: Es dürfen unter keinen Umständen Wählerstimmen verloren gehen, daher müssen diese repliziert werden.

    \item Datenintegrität: Da ein Wähler nicht mehrmals wählen darf, kann die Datenstruktur nicht nach Wahlkreis, Partei oder Kandidaten partitioniert sein, da dies bei vielen Schreiboperationen die Leistung drastisch reduzieren würde. Wären die Daten partitioniert, müsste man bei jeder Schreiboperation jede Partition abfragen, ob der vorliegende Eintrag gültig ist oder nicht.

    \item Ausfallsicherheit: Wie anfangs festgelegt, muss das System ausfallsicher sein und keinen einzigen Ausfallpunkt besitzen dürfen. Die Wählerstimmen dürfen also nicht an einem einzigen Ort gespeichert sein, und es darf nicht über eine einzige Instanz mit den Daten interagiert werden.
 
\end{itemize} 

Wir fassen also zusammen, dass wir eine verteilte Datenbank brauchen, welche schnelle Schreibgeschwindigkeiten unterstützt und die Daten nicht partitioniert werden. \\
Desweiteren brauchen wir mehrere Backend Intanzen, welche mit der verteilten Datenbank interagieren. \\

\newpage
\section{Cassandra}
Cassandra

\newpage
\section{Architektur}
Architektur


\newpage
\section{Implementation}
\subsection{Docker Compose}
\subsection{FastApi Backend}
\subsection{React Frontend}
\newpage


\end{document}